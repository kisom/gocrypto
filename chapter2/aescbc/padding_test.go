package aescbc

import (
	"bytes"
	"crypto/aes"
	"testing"
)

type padTest struct {
	Padded   []byte
	Unpadded []byte
}

var cases = []padTest{
	padTest{
		[]byte{0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10},
		[]byte{},
	},
	padTest{
		[]byte{0x41, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf},
		[]byte("A"),
	},
	padTest{
		[]byte{0x41, 0x41, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe},
		[]byte("AA"),
	},
	padTest{
		[]byte{0x41, 0x41, 0x41, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd},
		[]byte("AAA"),
	},
	padTest{
		[]byte{0x41, 0x41, 0x41, 0x41, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc},
		[]byte("AAAA"),
	},
	padTest{
		[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb},
		[]byte("AAAAA"),
	},
	padTest{
		[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa},
		[]byte("AAAAAA"),
	},
	padTest{
		[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9},
		[]byte("AAAAAAA"),
	},
	padTest{
		[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8},
		[]byte("AAAAAAAA"),
	},
	padTest{
		[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07},

		[]byte("AAAAAAAAA"),
	},
	padTest{
		[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06},
		[]byte("AAAAAAAAAA"),
	},
	padTest{
		[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x05, 0x05, 0x05, 0x05, 0x05},
		[]byte("AAAAAAAAAAA"),
	},
	padTest{
		[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x04, 0x04, 0x04, 0x04},
		[]byte("AAAAAAAAAAAA"),
	},
	padTest{
		[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x03, 0x03, 0x03},
		[]byte("AAAAAAAAAAAAA"),
	},
	padTest{
		[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x02, 0x02},
		[]byte("AAAAAAAAAAAAAA"),
	},
	padTest{
		[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x01},
		[]byte("AAAAAAAAAAAAAAA"),
	},
	padTest{
		[]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10},
		[]byte("AAAAAAAAAAAAAAAA"),
	},
}

func TestPad(t *testing.T) {
	for _, c := range cases {
		padded := Pad(c.Unpadded)
		if !bytes.Equal(padded, c.Padded) {
			t.Fatalf("Padding failed:\n\t%v\n\t%v\n", padded, c.Padded)
		}
	}
}

func TestUnpad(t *testing.T) {
	for _, c := range cases {
		unpadded := Unpad(c.Padded)
		if !bytes.Equal(unpadded, c.Unpadded) {
			t.Fatalf("Padding failed:\n\t%v\n\t%v\n", unpadded, c.Unpadded)
		}
	}
}

func TestBadUnpad(t *testing.T) {
	padded := []byte{0xa}
	p := Unpad(padded)
	if p != nil {
		t.Fatal("Unpadding should fail.")
	}

	padded = make([]byte, aes.BlockSize+2)
	padded[aes.BlockSize+1] = 0x11
	p = Unpad(padded)
	if p != nil {
		t.Fatal("Unpadding should fail.")
	}

	padded = make([]byte, 14)
	padded = append(padded, 3)
	padded = append(padded, 3)
	p = Unpad(padded)
	if p != nil {
		t.Fatal("Unpadding should fail.")
	}

	padded = make([]byte, 16)
	p = Unpad(padded)
	if p != nil {
		t.Fatal("Unpadding should fail.")
	}
}
